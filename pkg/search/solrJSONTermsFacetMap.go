package search

type JSONTermsFacetMap JSONFacetMap // https://github.com/apache/lucene-solr/blob/master/solr/solrj/src/java/org/apache/solr/client/solrj/request/json/TermsFacetMap.java

func CreateJSONTermsFacetMap(field string) *JSONTermsFacetMap {
	jfm := CreateJSONFacetMap("terms")
	(*jfm)["field"] = field
	return (*JSONTermsFacetMap)(jfm)
}

func (jfm *JSONTermsFacetMap) JSONFacetMap() *JSONFacetMap {
	return (*JSONFacetMap)(jfm)
}

/**
 * Indicates that Solr should skip over the N buckets for this facet.
 *
 * Used for "paging" in facet results.  Defaults to 0 if not provided.
 *
 * @param numToSkip the number of buckets to skip over before selecting the buckets to return
 */
func (jfm *JSONTermsFacetMap) setBucketOffset(numToSkip int64) *JSONTermsFacetMap {
	if numToSkip < 0 {
		numToSkip = 0
	}
	(*jfm)["offset"] = numToSkip
	return jfm
}

/**
 * Indicates the maximum number of buckets to be returned by this facet.
 *
 * Defaults to 10 if not specified.
 */
func (jfm *JSONTermsFacetMap) setLimit(maximumBuckets int64) *JSONTermsFacetMap {
	(*jfm)["Limit"] = maximumBuckets
	return jfm
}

/**
 * Indicates the desired ordering for the returned buckets.
 *
 * Values can be based on 'count' (the number of results in each bucket), 'index' (the natural order of bucket values),
 * or on any stat facet that occurs in the bucket.  Defaults to "count desc" if not specified.
 *
 * By default, {@code sort} is calculated for all buckets generated by all shards.  If {@code sort} is expensive a
 * cheaper approximation can be provided using {@link #setPreliminarySort(String)} that will be run instead during
 * bucket collection.
 *
 * @see TermsFacetMap#setPreliminarySort(String)
 */
func (jfm *JSONTermsFacetMap) setSort(sortString string) *JSONTermsFacetMap {
	if sortString == "" {
		return jfm
	}
	(*jfm)["sort"] = sortString
	return jfm
}

/**
 * Indicates an approximate sort calculation to be performed during initial bucket generation and collection.
 *
 * Values can be based on 'count' (the number of results in each bucket), 'index' (the natural order of bucket values),
 * or on any stat facet that occurs in the bucket.  Defaults to "count desc" if not specified.
 *
 * When no {@code prelim_sort} is provided, {@code sort} is calculated on all buckets generated by all shards.  If
 * {@code sort} is expensive, {@code prelim_sort} can be used to provide a cheaper approximation calculation that is
 * run instead on initial bucket collection.  {@code sort} is still used when assembling the final list of buckets.
 *
 * @see TermsFacetMap#setSort(String)
 */
func (jfm *JSONTermsFacetMap) SetPreliminarySort(preliminarySort string) *JSONTermsFacetMap {
	if preliminarySort == "" {
		return jfm
	}
	(*jfm)["prelim_sort"] = preliminarySort
	return jfm
}

/**
 * Indicates the number of additional buckets to request internally beyond those required by {@link #setLimit(int)}.
 *
 * Defaults to -1 if not specified, which triggers some heuristic guessing based on other settings.
 */
func (jfm *JSONTermsFacetMap) SetOverRequest(numExtraBuckets int64) *JSONTermsFacetMap {
	if numExtraBuckets < -1 {
		numExtraBuckets = -1
	}
	(*jfm)["overrequest"] = numExtraBuckets
	return jfm
}

/**
 * Indicates whether this facet should use distributed facet refining.
 *
 * "Distributed facet refining" is a second, optional stage in the facet process that ensures that counts for the
 * returned buckets are exact.  Enabling it is a tradeoff between precision and speed/performance.  Defaults to false
 * if not specified.
 * @param useRefining true if distributed facet refining should be used; false otherwise
 */
func (jfm *JSONTermsFacetMap) UseDistributedFacetRefining(useRefining bool) *JSONTermsFacetMap {
	(*jfm)["refine"] = useRefining
	return jfm
}

/**
 * Indicates how many extra buckets to request during distributed-facet-refining beyond those required by {@link #setLimit(int)}
 *
 * Defaults to -1 if not specified, which triggers some heuristic guessing based on other settings.
 */
func (jfm *JSONTermsFacetMap) SetOverRefine(numExtraBuckets int64) *JSONTermsFacetMap {
	if numExtraBuckets < -1 {
		numExtraBuckets = -1
	}
	(*jfm)["overrefine"] = numExtraBuckets
	return jfm
}

/**
 * Indicates that the facet results should not include any buckets with a count less than {@code minCount}.
 *
 * Defaults to 1 if not specified.
 */
func (jfm *JSONTermsFacetMap) SetMinCount(minCount int64) *JSONTermsFacetMap {
	if minCount < 0 {
		minCount = 0
	}
	(*jfm)["mincount"] = minCount
	return jfm
}

/**
 * Indicates that Solr should create a bucket corresponding to documents missing the field used by this facet.
 *
 * Defaults to false if not specified.
 *
 * @param missingBucket true if the special "missing" bucket should be created; false otherwise
 */
func (jfm *JSONTermsFacetMap) IncludeMissingBucket(missingBucket bool) *JSONTermsFacetMap {
	(*jfm)["missing"] = missingBucket
	return jfm
}

/**
 * Indicates that Solr should include the total number of buckets for this facet.
 *
 * Note that this is different than the number of buckets returned.  Defaults to false if not specified
 *
 * @param numBuckets true if the "numBuckets" field should be computed; false otherwise
 */
func (jfm *JSONTermsFacetMap) IncludeTotalNumBuckets(numBuckets bool) *JSONTermsFacetMap {
	(*jfm)["numBuckets"] = numBuckets
	return jfm
}

/**
 * Creates a bucket representing the union of all other buckets.
 *
 * For multi-valued Fields this is different than a bucket for the entire domain, since documents can belong to
 * multiple buckets.  Defaults to false if not specified.
 *
 * @param shouldInclude true if the union bucket "allBuckets" should be computed; false otherwise
 */
func (jfm *JSONTermsFacetMap) IncludeAllBucketsUnionBucket(shouldInclude bool) *JSONTermsFacetMap {
	(*jfm)["allBuckets"] = shouldInclude
	return jfm
}

/**
 * Indicates that the facet should only produce buckets for terms that SearchResultStart with the specified Prefix.
 */
func (jfm *JSONTermsFacetMap) SetTermPrefix(termPrefix string) *JSONTermsFacetMap {
	if termPrefix == "" {
		return jfm
	}
	(*jfm)["Prefix"] = termPrefix
	return jfm
}

/*
public enum FacetMethod {
DV("dv"), UIF("uif"), DVHASH("dvhash"), ENUM("enum"), STREAM("stream"), SMART("smart");

private final String value;
FacetMethod(String value) {
this.value = value;
}

public String toString() {
return value;
}
}

*/

/**
 * Indicate which method should be used to compute the facet.
 *
 * Defaults to "smart" if not specified, which has Solr guess which computation method will be most efficient.
 */
func (jfm *JSONTermsFacetMap) setFacetMethod(method string) *JSONTermsFacetMap {
	(*jfm)["method"] = method
	return jfm
}
